package schema

import (
	"context"
	"testing"

	"github.com/spaceuptech/space-cloud/gateway/config"
	"github.com/spaceuptech/space-cloud/gateway/model"
	"github.com/spaceuptech/space-cloud/gateway/modules/crud"
)

func TestSchema_generateCreationQueries(t *testing.T) {
	type fields struct {
		SchemaDoc model.Type
		crud      model.CrudSchemaInterface
		project   string
		config    config.DatabaseSchemas
	}
	type args struct {
		dbAlias       string
		tableName     string
		project       string
		parsedSchema  model.Type
		currentSchema model.Collection
	}

	crudPostgres := crud.Init()
	_ = crudPostgres.SetConfig("test", config.DatabaseConfigs{config.GenerateResourceID("chicago", "myproject", config.ResourceDatabaseConfig, "postgres"): &config.DatabaseConfig{DbAlias: "postgres", Type: "sql-postgres", Enabled: false}})

	crudMySQL := crud.Init()
	_ = crudMySQL.SetConfig("test", config.DatabaseConfigs{config.GenerateResourceID("chicago", "myproject", config.ResourceDatabaseConfig, "mysql"): &config.DatabaseConfig{DbAlias: "mysql", Type: "sql-mysql", Enabled: false}})

	crudSQLServer := crud.Init()
	_ = crudSQLServer.SetConfig("test", config.DatabaseConfigs{config.GenerateResourceID("chicago", "myproject", config.ResourceDatabaseConfig, "sqlserver"): &config.DatabaseConfig{DbAlias: "sqlserver", Type: "sql-sqlserver", Enabled: false}})

	tests := []struct {
		name    string
		fields  fields
		args    args
		want    []string
		isSort  bool
		wantErr bool
	}{
		// TODO: test cases restructuring
		{
			name: "Mysql no queries generated when both schemas have 2 fields with type ID",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 2 fields 1 with type ID & other having type String",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 2 fields 1 with type ID & other having type Integer",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 2 fields 1 with type ID & other having type Float",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeFloat, Args: &model.FieldArgs{Precision: model.DefaultPrecision, Scale: model.DefaultScale}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeFloat, Args: &model.FieldArgs{Precision: model.DefaultPrecision, Scale: model.DefaultScale}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 2 fields 1 with type ID & other having type DateTime",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeDateTime, Args: &model.FieldArgs{Scale: model.DefaultScale}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeDateTime, Args: &model.FieldArgs{Scale: model.DefaultScale}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 2 fields 1 with type ID & other having type JSON",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeJSON}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeJSON}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 2 fields with type ID not null",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 2 fields 1 with type ID & other having type String not null",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 2 fields 1 with type ID & other having type Integer not null",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 2 fields 1 with type ID & other having type Float not null",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeFloat, Args: &model.FieldArgs{Precision: model.DefaultPrecision, Scale: model.DefaultScale}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeFloat, Args: &model.FieldArgs{Precision: model.DefaultPrecision, Scale: model.DefaultScale}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 2 fields 1 with type ID & other having type DateTime not null",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeDateTime, Args: &model.FieldArgs{Precision: model.DefaultPrecision}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeDateTime, Args: &model.FieldArgs{Precision: model.DefaultPrecision}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 2 fields 1 with type ID & other having type JSON not null",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeJSON}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeJSON}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 2 fields with type ID with default value",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "INDIA", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "INDIA", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 2 fields 1 with type ID & other having type String with default value",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "INDIA", Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "INDIA", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 2 fields 1 with type ID & other having type Integer with default value",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "100", Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "100", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 2 fields 1 with type ID & other having type Float with default value",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "9.8", Kind: model.TypeFloat, Args: &model.FieldArgs{Precision: model.DefaultPrecision, Scale: model.DefaultScale}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "9.8", Kind: model.TypeFloat, Args: &model.FieldArgs{Precision: model.DefaultPrecision, Scale: model.DefaultScale}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 2 fields 1 with type ID & other having type DateTime with default value",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "2020-05-30T00:42:05+00:00", Kind: model.TypeDateTime, Args: &model.FieldArgs{Precision: model.DefaultPrecision}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "2020-05-30T00:42:05+00:00", Kind: model.TypeDateTime, Args: &model.FieldArgs{Precision: model.DefaultPrecision}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 2 fields 1 with type ID & other having type JSON with default value",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: `{"id":"zerfvnex","name":"john"}`, Kind: model.TypeJSON}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: `{"id":"zerfvnex","name":"john"}`, Kind: model.TypeJSON}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have only 1 primary key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 2 fields 1 with type ID & other having type ID with foreign key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id", ConstraintName: getConstraintName("table2", "id"), OnDelete: "NO ACTION"}, TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id", ConstraintName: getConstraintName("table2", "id"), OnDelete: "NO ACTION"}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 2 fields 1 with type ID & other having type ID with foreign key on delete CASCADE",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id", ConstraintName: getConstraintName("table2", "id"), OnDelete: "CASCADE"}, TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id", ConstraintName: getConstraintName("table2", "id"), OnDelete: "CASCADE"}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 2 fields 1 with type ID & other having type ID with index",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsIndex: true, Group: "group1", Order: 1, Sort: "asc"}}, TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsIndex: true, Group: "group1", Order: 1, Sort: "asc"}}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 3 fields 1 with type ID & other having type ID with index in group1",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsIndex: true, Group: "group1", Order: 1, Sort: "asc"}}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}, "col3": &model.FieldType{FieldName: "col3", IndexInfo: []*model.TableProperties{{IsIndex: true, Group: "group1", Order: 2, Sort: "asc"}}, TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsIndex: true, Group: "group1", Order: 1, Sort: "asc"}}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}, "col3": &model.FieldType{FieldName: "col3", IndexInfo: []*model.TableProperties{{IsIndex: true, Group: "group1", Order: 2, Sort: "asc"}}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 2 fields 1 with type ID & other having type ID with index",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsUnique: true, Group: "group1", Order: 1, Sort: "asc"}}, TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsUnique: true, Group: "group1", Order: 1, Sort: "asc"}}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Mysql no queries generated when both schemas have 3 fields 1 with type ID & other having type ID with index in group1",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsUnique: true, Group: "group1", Order: 1, Sort: "asc"}}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}, "col3": &model.FieldType{FieldName: "col3", IndexInfo: []*model.TableProperties{{IsUnique: true, Group: "group1", Order: 2, Sort: "asc"}}, TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsUnique: true, Group: "group1", Order: 1, Sort: "asc"}}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}, "col3": &model.FieldType{FieldName: "col3", IndexInfo: []*model.TableProperties{{IsUnique: true, Group: "group1", Order: 2, Sort: "asc"}}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "cannot remove a column with primary key - mysql",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col2": &model.FieldType{FieldName: "col2", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: true,
		},
		{
			name: "cannot modify type of column with primary key - mysql",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: true,
		},
		{
			name: "adding a table and column of type JSON",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: true, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON, IsFieldTypeRequired: true}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE TABLE table1 (id varchar(50) NOT NULL , col1 json NOT NULL ,PRIMARY KEY (id));"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type integer with default key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IsDefault: true, Default: 543}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE TABLE table1 (id varchar(50) NOT NULL , col1 bigint NOT NULL ,PRIMARY KEY (id));", "ALTER TABLE table1 ALTER col1 SET DEFAULT 543"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type float with default key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat, Args: &model.FieldArgs{Scale: model.DefaultScale, Precision: model.DefaultPrecision}, IsFieldTypeRequired: true, IsDefault: true, Default: 5.2}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE TABLE table1 (id varchar(50) NOT NULL , col1 decimal(10,3) NOT NULL ,PRIMARY KEY (id));", "ALTER TABLE table1 ALTER col1 SET DEFAULT 5.2"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type string with default key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString, IsFieldTypeRequired: true, IsDefault: true, Default: "string"}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE TABLE table1 (id varchar(50) NOT NULL , col1 text NOT NULL ,PRIMARY KEY (id));", "ALTER TABLE table1 ALTER col1 SET DEFAULT 'string'"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type boolean with default key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeBoolean, IsFieldTypeRequired: true, IsDefault: true, Default: true}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE TABLE table1 (id varchar(50) NOT NULL , col1 boolean NOT NULL ,PRIMARY KEY (id));", "ALTER TABLE table1 ALTER col1 SET DEFAULT true"},
			wantErr: false,
		},
		{
			name: "removing a table and column of type boolean with default key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeBoolean}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeBoolean, IsDefault: true, Default: true}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 ALTER col1 DROP DEFAULT"},
			wantErr: false,
		},
		{
			name: "adding two columns",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{}},
			},
			isSort:  true,
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 ADD col1 varchar(50)", "ALTER TABLE table1 ADD col2 text"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type integer",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE TABLE table1 (id varchar(50) NOT NULL , col1 bigint ,PRIMARY KEY (id));", "ALTER TABLE table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and a foreign key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeDateTime, Args: &model.FieldArgs{Scale: model.DefaultScale}, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col2"), To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE TABLE table1 (id varchar(50) NOT NULL , col2 datetime(3) ,PRIMARY KEY (id));", "ALTER TABLE table1 ADD CONSTRAINT c_table1_col2 FOREIGN KEY (col2) REFERENCES table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and a foreign key with ON DELETE CASCADE",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeDateTime, Args: &model.FieldArgs{Scale: model.DefaultScale}, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id", ConstraintName: getConstraintName("table1", "col2"), OnDelete: "CASCADE"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE TABLE table1 (id varchar(50) NOT NULL , col2 datetime(3) ,PRIMARY KEY (id));", "ALTER TABLE table1 ADD CONSTRAINT c_table1_col2 FOREIGN KEY (col2) REFERENCES table2 (id) ON DELETE CASCADE"},
			wantErr: false,
		},
		{
			name: "current Schema with NO ACTION and parsedSchema with ON CASCADE DELETE ",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, Args: &model.FieldArgs{Precision: model.DefaultPrecision, Scale: model.DefaultScale}, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id", OnDelete: "CASCADE"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, Args: &model.FieldArgs{Precision: model.DefaultPrecision, Scale: model.DefaultScale}, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 DROP FOREIGN KEY c_table1_col1", "ALTER TABLE table1 DROP INDEX c_table1_col1", "ALTER TABLE table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES table2 (id) ON DELETE CASCADE"},
			wantErr: false,
		},
		{
			name: "current Schema with CASCADE and parsedSchema with NO ACTION ",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, Args: &model.FieldArgs{Precision: model.DefaultPrecision, Scale: model.DefaultScale}, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, Args: &model.FieldArgs{Precision: model.DefaultPrecision, Scale: model.DefaultScale}, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id", OnDelete: "CASCADE"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 DROP FOREIGN KEY c_table1_col1", "ALTER TABLE table1 DROP INDEX c_table1_col1", "ALTER TABLE table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type boolean",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeBoolean, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE TABLE table1 (id varchar(50) NOT NULL , col1 boolean ,PRIMARY KEY (id));", "ALTER TABLE table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and a primary key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col3": &model.FieldType{FieldName: "col3", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: true, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE TABLE table1 (col3 varchar(50) NOT NULL , PRIMARY KEY (col3));"},
			wantErr: false,
		},
		{
			name: "changing type of column with primary key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col3": &model.FieldType{FieldName: "col3", Kind: model.TypeInteger, IsFieldTypeRequired: true, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col3": &model.FieldType{FieldName: "col3", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: true, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: true,
		},
		{
			name: "removing one column",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 DROP COLUMN col1"},
			wantErr: false,
		},
		{
			name: "required to unrequired",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: true}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 MODIFY col1 varchar(50) NOT NULL"},
			wantErr: false,
		},
		{
			name: "unrequired to required",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: true}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 MODIFY col1 varchar(50) NULL"},
			wantErr: false,
		},
		{
			name: "integer to JSON",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 DROP COLUMN col1", "ALTER TABLE table1 ADD col1 json"},
			wantErr: false,
		},
		{
			name: "JSON to integer",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 DROP COLUMN col1", "ALTER TABLE table1 ADD col1 bigint"},
			wantErr: false,
		},
		{
			name: "JSON to string",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 DROP COLUMN col1", "ALTER TABLE table1 ADD col1 text"},
			wantErr: false,
		},
		{
			name: "integer to string",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 DROP COLUMN col1", "ALTER TABLE table1 ADD col1 text"},
			wantErr: false,
		},
		{
			name: "string to integer",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 DROP COLUMN col1", "ALTER TABLE table1 ADD col1 bigint"},
			wantErr: false,
		},
		{
			name: "integer to float",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat, Args: &model.FieldArgs{Scale: model.DefaultScale, Precision: model.DefaultPrecision}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 DROP COLUMN col1", "ALTER TABLE table1 ADD col1 decimal(10,3)"},
			wantErr: false,
		},
		{
			name: "float to integer",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 DROP COLUMN col1", "ALTER TABLE table1 ADD col1 bigint"},
			wantErr: false,
		},
		{
			name: "float to dateTime",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, Args: &model.FieldArgs{Scale: model.DefaultScale}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 DROP COLUMN col1", "ALTER TABLE table1 ADD col1 datetime(3)"},
			wantErr: false,
		},
		{
			name: "datetime to float",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat, Args: &model.FieldArgs{Scale: model.DefaultScale, Precision: model.DefaultPrecision}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 DROP COLUMN col1", "ALTER TABLE table1 ADD col1 decimal(10,3)"},
			wantErr: false,
		},
		{
			name: "datetime to id",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 DROP COLUMN col1", "ALTER TABLE table1 ADD col1 varchar(50)"},
			wantErr: false,
		},
		{
			name: "id to datetime",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, Args: &model.FieldArgs{Scale: model.DefaultScale}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 DROP COLUMN col1", "ALTER TABLE table1 ADD col1 datetime(3)"},
			wantErr: false,
		},
		{
			name: "adding primary directive to type Json",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: true,
		},
		{
			name: "adding unique directive to type Json",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON, IsFieldTypeRequired: true, IndexInfo: []*model.TableProperties{{IsUnique: true}}}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: true,
		},
		{
			name: "adding index directive to type Json",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON, IsFieldTypeRequired: true, IndexInfo: []*model.TableProperties{{IsIndex: true}}}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: true,
		},
		{
			name: "trying to mutate a primary key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: true, IsDefault: true}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: true, IsPrimary: true}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: true,
		},
		{
			name: "removing primary key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: false, IsPrimary: false}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: true, IsPrimary: true}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: true,
		},
		{
			name: "adding foreign key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsForeign: false}}, "table2": model.Fields{}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding foreign key with type change",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsForeign: false}}, "table2": model.Fields{}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 DROP COLUMN col1", "ALTER TABLE table1 ADD col1 bigint", "ALTER TABLE table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES table2 (id)"},
			wantErr: false,
		},
		{
			name: "removing foreign key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: false, IsForeign: false}}, "table2": model.Fields{"id": &model.FieldType{FieldName: "col1", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 DROP FOREIGN KEY c_table1_col1", "ALTER TABLE table1 DROP INDEX c_table1_col1"},
			wantErr: false,
		},
		{
			name: "removing foreign key and type change",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: false, IsForeign: false}}, "table2": model.Fields{"id": &model.FieldType{FieldName: "col1", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 DROP FOREIGN KEY c_table1_col1", "ALTER TABLE table1 DROP INDEX c_table1_col1", "ALTER TABLE table1 DROP COLUMN col1", "ALTER TABLE table1 ADD col1 bigint"},
			wantErr: false,
		},
		{
			name: "adding link",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsLinked: true, LinkedTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 DROP COLUMN col1"},
			wantErr: false,
		},
		{
			name: "removing link",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: false, IsForeign: false}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsLinked: true, LinkedTable: &model.TableProperties{Table: "table2", To: "id"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 ADD col1 varchar(50)"},
			wantErr: false,
		},
		{
			name: "Wrong dbAlias",
			args: args{
				dbAlias:       "wrgDbAlias",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{}}},
				currentSchema: model.Collection{"table1": model.Fields{}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			wantErr: true,
		},
		{
			name: "when table is not provided",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			wantErr: false,
		},
		{
			name: "tablename  present in currentschema but not in realschema",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			wantErr: true,
		},
		{
			name: "tablename  not present in currentschema, realschema",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			wantErr: false,
		},
		{
			name: "tablename  present in realschema but not in realschema",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE TABLE table1 (id varchar(50) NOT NULL , col1 varchar(50) ,PRIMARY KEY (id));"},
			wantErr: false,
		},
		{
			name: "fieldtype of type object in realschema",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeObject}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			wantErr: true,
		},
		{
			name: "invalid fieldtype in realschema and table not present in current schema",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeObject}}}},
				currentSchema: model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			wantErr: true,
		},
		{
			name: "invalid fieldtype in realschema",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: "int"}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeObject}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			wantErr: true,
		},
		{
			name: "doing nthg",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "doing nthg composite",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "adding index key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 MODIFY col1 bigint NOT NULL", "CREATE INDEX index__table1__ ON table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "adding index key to existing index",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 2, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 ADD col2 bigint", "DROP INDEX index__table1__i1 ON table1", "CREATE INDEX index__table1__i1 ON table1 (col1 asc, col2 asc)"},
			wantErr: false,
		},
		{
			name: "adding new index key ",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, Group: "i2", Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 ADD col2 bigint", "CREATE INDEX index__table1__i2 ON table1 (col2 asc)"},
			wantErr: false,
		},
		{
			name: "adding unique key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IndexInfo: []*model.TableProperties{{Field: "col1", IsUnique: true, IsIndex: true, Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 MODIFY col1 bigint NOT NULL", "CREATE UNIQUE INDEX index__table1__ ON table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "adding unique index key to existing index",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 2, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 ADD col2 bigint", "DROP INDEX index__table1__i1 ON table1", "CREATE UNIQUE INDEX index__table1__i1 ON table1 (col1 asc, col2 asc)"},
			wantErr: false,
		},
		{
			name: "adding new unique index key ",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, Group: "i2", Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE table1 ADD col2 bigint", "CREATE UNIQUE INDEX index__table1__i2 ON table1 (col2 asc)"},
			wantErr: false,
		},
		{
			name: "changing index to unique",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON table1", "CREATE UNIQUE INDEX index__table1__i1 ON table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing unique to index",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON table1", "CREATE INDEX index__table1__i1 ON table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing order of unique index key ",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 2, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 2, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON table1", "CREATE UNIQUE INDEX index__table1__i1 ON table1 (col2 asc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing order of index key ",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 2, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 2, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON table1", "CREATE INDEX index__table1__i1 ON table1 (col2 asc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing group of unique index key ",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i2", ConstraintName: getIndexName("table1", "i2"), Order: 2, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, Group: "i2", ConstraintName: getIndexName("table1", "i2"), Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 2, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON table1", "CREATE UNIQUE INDEX index__table1__i2 ON table1 (col2 asc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing qroup of index key ",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i2", ConstraintName: getIndexName("table1", "i2"), Order: 2, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, Group: "i2", ConstraintName: getIndexName("table1", "i2"), Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 2}}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON table1", "CREATE INDEX index__table1__i2 ON table1 (col2 asc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing sort of unique index key ",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 2, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 1, Sort: "desc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 1, Sort: "desc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 2, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON table1", "CREATE UNIQUE INDEX index__table1__i1 ON table1 (col2 desc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing sort of index key ",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 2, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 1, Sort: "desc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 2, Sort: "desc"}}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON table1", "CREATE INDEX index__table1__i1 ON table1 (col1 asc, col2 asc)"},
			wantErr: false,
		},
		{
			name: "adding invalid order key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IndexInfo: []*model.TableProperties{{IsIndex: true, Order: 2}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			wantErr: true,
		},

		// //sql-server
		{
			name: "SQL-Server no queries generated when both schemas have 2 fields with type ID",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "SQL-Server no queries generated when both schemas have 2 fields 1 with type ID & other having type String",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "SQL-Server no queries generated when both schemas have 2 fields 1 with type ID & other having type Integer",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "SQL-Server no queries generated when both schemas have 2 fields 1 with type ID & other having type Float",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeFloat}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeFloat}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "SQL-Server no queries generated when both schemas have 2 fields 1 with type ID & other having type DateTime",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeDateTime}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeDateTime}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "SQL-Server no queries generated when both schemas have 2 fields with type ID not null",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "SQL-Server no queries generated when both schemas have 2 fields 1 with type ID & other having type String not null",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "SQL-Server no queries generated when both schemas have 2 fields 1 with type ID & other having type Integer not null",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "SQL-Server no queries generated when both schemas have 2 fields 1 with type ID & other having type Float not null",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeFloat}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeFloat}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "SQL-Server no queries generated when both schemas have 2 fields 1 with type ID & other having type DateTime not null",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeDateTime}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeDateTime}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "SQL-Server no queries generated when both schemas have 2 fields with type ID with default value",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "INDIA", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "INDIA", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "SQL-Server no queries generated when both schemas have 2 fields 1 with type ID & other having type String with default value",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "INDIA", Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "INDIA", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "SQL-Server no queries generated when both schemas have 2 fields 1 with type ID & other having type Integer with default value",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "100", Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "100", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "SQL-Server no queries generated when both schemas have 2 fields 1 with type ID & other having type Float with default value",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "9.8", Kind: model.TypeFloat}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "9.8", Kind: model.TypeFloat}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "SQL-Server no queries generated when both schemas have 2 fields 1 with type ID & other having type DateTime with default value",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "2020-05-30T00:42:05+00:00", Kind: model.TypeDateTime}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "2020-05-30T00:42:05+00:00", Kind: model.TypeDateTime}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "SQL-Server no queries generated when both schemas have only 1 primary key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "SQL-Server no queries generated when both schemas have 2 fields 1 with type ID & other having type ID with foreign key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id", ConstraintName: getConstraintName("table2", "id"), OnDelete: "NO ACTION"}, TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id", ConstraintName: getConstraintName("table2", "id"), OnDelete: "NO ACTION"}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "SQL-Server no queries generated when both schemas have 2 fields 1 with type ID & other having type ID with foreign key on delete CASCADE",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id", ConstraintName: getConstraintName("table2", "id"), OnDelete: "CASCADE"}, TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id", ConstraintName: getConstraintName("table2", "id"), OnDelete: "CASCADE"}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "SQL-Server no queries generated when both schemas have 2 fields 1 with type ID & other having type ID with index",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsIndex: true, Group: "group1", Order: 1, Sort: "asc"}}, TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsIndex: true, Group: "group1", Order: 1, Sort: "asc"}}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "SQL-Server no queries generated when both schemas have 3 fields 1 with type ID & other having type ID with index in group1",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsIndex: true, Group: "group1", Order: 1, Sort: "asc"}}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}, "col3": &model.FieldType{FieldName: "col3", IndexInfo: []*model.TableProperties{{IsIndex: true, Group: "group1", Order: 2, Sort: "asc"}}, TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsIndex: true, Group: "group1", Order: 1, Sort: "asc"}}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}, "col3": &model.FieldType{FieldName: "col3", IndexInfo: []*model.TableProperties{{IsIndex: true, Group: "group1", Order: 2, Sort: "asc"}}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "SQL-Server no queries generated when both schemas have 2 fields 1 with type ID & other having type ID with index",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsUnique: true, Group: "group1", Order: 1, Sort: "asc"}}, TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsUnique: true, Group: "group1", Order: 1, Sort: "asc"}}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "SQL-Server no queries generated when both schemas have 3 fields 1 with type ID & other having type ID with index in group1",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsUnique: true, Group: "group1", Order: 1, Sort: "asc"}}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}, "col3": &model.FieldType{FieldName: "col3", IndexInfo: []*model.TableProperties{{IsUnique: true, Group: "group1", Order: 2, Sort: "asc"}}, TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsUnique: true, Group: "group1", Order: 1, Sort: "asc"}}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}, "col3": &model.FieldType{FieldName: "col3", IndexInfo: []*model.TableProperties{{IsUnique: true, Group: "group1", Order: 2, Sort: "asc"}}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "adding a table and column of type JSON",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON, IsFieldTypeRequired: true}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (id varchar(50) NOT NULL , col1 nvarchar(max) constraint json_check_table1_col1 CHECK (ISJSON(col1)=1) NOT NULL ,PRIMARY KEY (id));"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type integer with default key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IsDefault: true, Default: 543}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (id varchar(50) NOT NULL , col1 bigint NOT NULL ,PRIMARY KEY (id));", "ALTER TABLE test.table1 ADD CONSTRAINT c_col1 DEFAULT 543 FOR col1"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type float with default key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat, Args: &model.FieldArgs{Scale: model.DefaultScale, Precision: model.DefaultPrecision}, IsFieldTypeRequired: true, IsDefault: true, Default: 5.2}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (id varchar(50) NOT NULL , col1 float NOT NULL ,PRIMARY KEY (id));", "ALTER TABLE test.table1 ADD CONSTRAINT c_col1 DEFAULT 5.2 FOR col1"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type string with default key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString, IsFieldTypeRequired: true, IsDefault: true, Default: "string"}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (id varchar(50) NOT NULL , col1 varchar(max) NOT NULL ,PRIMARY KEY (id));", "ALTER TABLE test.table1 ADD CONSTRAINT c_col1 DEFAULT 'string' FOR col1"},
			wantErr: false,
		},
		{
			name: "removing a table and column of type boolean with default key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeBoolean}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeBoolean, IsDefault: true, Default: true}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP CONSTRAINT c_col1"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type boolean with default key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeBoolean, IsFieldTypeRequired: true, IsDefault: true, Default: true}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (id varchar(50) NOT NULL , col1 bit NOT NULL ,PRIMARY KEY (id));", "ALTER TABLE test.table1 ADD CONSTRAINT c_col1 DEFAULT 1 FOR col1"},
			wantErr: false,
		},
		{
			name: "adding two columns",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{}},
			},
			isSort:  true,
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD col1 varchar(50)", "ALTER TABLE test.table1 ADD col2 varchar(max)"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type integer",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (id varchar(50) NOT NULL , col1 bigint ,PRIMARY KEY (id));", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and a foreign key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeDateTime, Args: &model.FieldArgs{Scale: model.DefaultScale}, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col2"), To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (id varchar(50) NOT NULL , col2 datetimeoffset ,PRIMARY KEY (id));", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col2 FOREIGN KEY (col2) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and a foreign key with ON DELETE CASCADE",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeDateTime, Args: &model.FieldArgs{Scale: model.DefaultScale}, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col2"), To: "id", OnDelete: "CASCADE"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (id varchar(50) NOT NULL , col2 datetimeoffset ,PRIMARY KEY (id));", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col2 FOREIGN KEY (col2) REFERENCES test.table2 (id) ON DELETE CASCADE"},
			wantErr: false,
		},
		{
			name: "current Schema with NO ACTION and parsedSchema with ON CASCADE DELETE ",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id", OnDelete: "CASCADE"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP CONSTRAINT c_table1_col1", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id) ON DELETE CASCADE"},
			wantErr: false,
		},
		{
			name: "current Schema with CASCADE and parsedSchema with NO ACTION ",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id", OnDelete: "CASCADE"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP CONSTRAINT c_table1_col1", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type boolean",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeBoolean, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (id varchar(50) NOT NULL , col1 bit ,PRIMARY KEY (id));", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and a primary key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col3": &model.FieldType{FieldName: "col3", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: true, PrimaryKeyInfo: &model.TableProperties{}, IsPrimary: true}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col3 varchar(50) NOT NULL , PRIMARY KEY (col3));"},
			wantErr: false,
		},
		{
			name: "removing one column",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1"},
			wantErr: false,
		},
		{
			name: "required to unrequired",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: true}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ALTER COLUMN col1 varchar(50) NOT NULL"},
			wantErr: false,
		},
		{
			name: "unrequired to required",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: true}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ALTER COLUMN col1 varchar(50) NULL"},
			wantErr: false,
		},
		{
			name: "integer to string",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 varchar(max)"},
			wantErr: false,
		},
		{
			name: "string to integer",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 bigint"},
			wantErr: false,
		},
		{
			name: "integer to float",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat, Args: &model.FieldArgs{Scale: model.DefaultScale, Precision: model.DefaultPrecision}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 float"},
			wantErr: false,
		},
		{
			name: "float to integer",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 bigint"},
			wantErr: false,
		},
		{
			name: "float to dateTime",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 datetimeoffset"},
			wantErr: false,
		},
		{
			name: "datetime to float",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 float"},
			wantErr: false,
		},
		{
			name: "datetime to id",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 varchar(50)"},
			wantErr: false,
		},
		{
			name: "id to datetime",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 datetimeoffset"},
			wantErr: false,
		},
		{
			name: "adding primary key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: true, PrimaryKeyInfo: &model.TableProperties{}, IsPrimary: true}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "removing primary key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: false, IsPrimary: false}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: true, IsPrimary: true}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: true,
		},
		{
			name: "adding foreign key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsForeign: false}}, "table2": model.Fields{}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding foreign key with type change",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsForeign: false}}, "table2": model.Fields{}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 bigint", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "removing foreign key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: false, IsForeign: false}}, "table2": model.Fields{"id": &model.FieldType{FieldName: "col1", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP CONSTRAINT c_table1_col1"},
			wantErr: false,
		},
		{
			name: "removing foreign key and type change",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: false, IsForeign: false}}, "table2": model.Fields{"id": &model.FieldType{FieldName: "col1", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP CONSTRAINT c_table1_col1", "ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 bigint"},
			wantErr: false,
		},
		{
			name: "adding link",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsLinked: true, LinkedTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1"},
			wantErr: false,
		},
		{
			name: "removing link",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: false, IsForeign: false}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsLinked: true, LinkedTable: &model.TableProperties{Table: "table2", To: "id"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD col1 varchar(50)"},
			wantErr: false,
		},
		{
			name: "Wrong dbAlias",
			args: args{
				dbAlias:       "wrgDbAlias",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{}}},
				currentSchema: model.Collection{"table1": model.Fields{}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			wantErr: true,
		},
		{
			name: "when table is not provided",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			wantErr: false,
		},
		{
			name: "tablename  present in currentschema but not in realschema",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			wantErr: true,
		},
		{
			name: "tablename  not present in currentschema, realschema",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			wantErr: false,
		},
		{
			name: "tablename  present in realschema but not in realschema",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (id varchar(50) NOT NULL , col1 varchar(50) ,PRIMARY KEY (id));"},
			wantErr: false,
		},
		{
			name: "fieldtype of type object in realschema",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeObject}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			wantErr: true,
		},
		{
			name: "invalid fieldtype in realschema and table not present in current schema",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeObject}}}},
				currentSchema: model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			wantErr: true,
		},
		{
			name: "invalid fieldtype in realschema",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: "int"}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeObject}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			wantErr: true,
		},
		{

			name: "adding a table and column of type JSON",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON, IsFieldTypeRequired: true}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (id varchar(50) NOT NULL , col1 jsonb NOT NULL ,PRIMARY KEY (id));"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type integer with default key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IsDefault: true, Default: 543}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (id varchar(50) NOT NULL , col1 bigint NOT NULL ,PRIMARY KEY (id));", "ALTER TABLE test.table1 ALTER COLUMN col1 SET DEFAULT 543"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type float with default key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat, Args: &model.FieldArgs{Scale: model.DefaultScale, Precision: model.DefaultPrecision}, IsFieldTypeRequired: true, IsDefault: true, Default: 5.2}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (id varchar(50) NOT NULL , col1 float NOT NULL ,PRIMARY KEY (id));", "ALTER TABLE test.table1 ALTER COLUMN col1 SET DEFAULT 5.2"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type string with default key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString, IsFieldTypeRequired: true, IsDefault: true, Default: "string"}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (id varchar(50) NOT NULL , col1 text NOT NULL ,PRIMARY KEY (id));", "ALTER TABLE test.table1 ALTER COLUMN col1 SET DEFAULT 'string'"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type boolean with default key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeBoolean, IsFieldTypeRequired: true, IsDefault: true, Default: true}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (id varchar(50) NOT NULL , col1 boolean NOT NULL ,PRIMARY KEY (id));", "ALTER TABLE test.table1 ALTER COLUMN col1 SET DEFAULT true"},
			wantErr: false,
		},
		{
			name: "adding two columns",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			isSort:  true,
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ALTER COLUMN col1 bigint NOT NULL", "CREATE INDEX index__table1__ ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "doing nthg",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "doing nthg composite",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "adding index key to existing index",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 2, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD col2 bigint", "DROP INDEX index__table1__i1 ON test.table1", "CREATE INDEX index__table1__i1 ON test.table1 (col1 asc, col2 asc)"},
			wantErr: false,
		},
		{
			name: "adding new index key ",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, Group: "i2", Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD col2 bigint", "CREATE INDEX index__table1__i2 ON test.table1 (col2 asc)"},
			wantErr: false,
		},
		{
			name: "adding unique key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IndexInfo: []*model.TableProperties{{Field: "col1", IsUnique: true, IsIndex: true, Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ALTER COLUMN col1 bigint NOT NULL", "CREATE UNIQUE INDEX index__table1__ ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "adding unique index key to existing index",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 2, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD col2 bigint", "DROP INDEX index__table1__i1 ON test.table1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col1 asc, col2 asc)"},
			wantErr: false,
		},
		{
			name: "adding new unique index key ",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, Group: "i2", Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD col2 bigint", "CREATE UNIQUE INDEX index__table1__i2 ON test.table1 (col2 asc)"},
			wantErr: false,
		},
		{
			name: "changing index to unique",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON test.table1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing index to unique",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON test.table1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing unique to index",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON test.table1", "CREATE INDEX index__table1__i1 ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing order of unique index key ",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 2, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 2, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON test.table1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col2 asc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing order of index key ",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 2, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 2, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON test.table1", "CREATE INDEX index__table1__i1 ON test.table1 (col2 asc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing group of unique index key ",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, ConstraintName: getIndexName("table1", "i2"), Group: "i2", Order: 2, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, ConstraintName: getIndexName("table1", "i2"), Group: "i2", Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 2, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON test.table1", "CREATE UNIQUE INDEX index__table1__i2 ON test.table1 (col2 asc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing qroup of index key ",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, ConstraintName: getIndexName("table1", "i2"), Group: "i2", Order: 2, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, ConstraintName: getIndexName("table1", "i2"), Group: "i2", Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 2}}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON test.table1", "CREATE INDEX index__table1__i2 ON test.table1 (col2 asc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing sort of unique index key ",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 2, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 1, Sort: "desc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 1, Sort: "desc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 2, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON test.table1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col2 desc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing sort of index key ",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 2, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 1, Sort: "desc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 2, Sort: "desc"}}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON test.table1", "CREATE INDEX index__table1__i1 ON test.table1 (col1 asc, col2 asc)"},
			wantErr: false,
		},
		{
			name: "adding invalid order key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IndexInfo: []*model.TableProperties{{IsIndex: true, Order: 2}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			wantErr: true,
		},

		// //postgres
		{
			name: "Postgres no queries generated when both schemas have 2 fields with type ID",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 2 fields 1 with type ID & other having type String",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 2 fields 1 with type ID & other having type Integer",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 2 fields 1 with type ID & other having type Float",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeFloat}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeFloat}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 2 fields 1 with type ID & other having type DateTime",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeDateTime}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeDateTime}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 2 fields 1 with type ID & other having type JSON",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeJSON}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeJSON}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 2 fields with type ID not null",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 2 fields 1 with type ID & other having type String not null",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 2 fields 1 with type ID & other having type Integer not null",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 2 fields 1 with type ID & other having type Float not null",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeFloat}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeFloat}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 2 fields 1 with type ID & other having type DateTime not null",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeDateTime}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeDateTime}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 2 fields 1 with type ID & other having type JSON not null",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeJSON}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsFieldTypeRequired: true, Kind: model.TypeJSON}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 2 fields with type ID with default value",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "INDIA", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "INDIA", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 2 fields 1 with type ID & other having type String with default value",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "INDIA", Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "INDIA", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 2 fields 1 with type ID & other having type Integer with default value",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "100", Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "100", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 2 fields 1 with type ID & other having type Float with default value",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "9.8", Kind: model.TypeFloat}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "9.8", Kind: model.TypeFloat}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 2 fields 1 with type ID & other having type DateTime with default value",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "2020-05-30T00:42:05+00:00", Kind: model.TypeDateTime}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: "2020-05-30T00:42:05+00:00", Kind: model.TypeDateTime}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 2 fields 1 with type ID & other having type JSON with default value",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: `{"id":"zerfvnex","name":"john"}`, Kind: model.TypeJSON}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsDefault: true, Default: `{"id":"zerfvnex","name":"john"}`, Kind: model.TypeJSON}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have only 1 primary key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 2 fields 1 with type ID & other having type ID with foreign key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id", ConstraintName: getConstraintName("table2", "id"), OnDelete: "NO ACTION"}, TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id", ConstraintName: getConstraintName("table2", "id"), OnDelete: "NO ACTION"}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 2 fields 1 with type ID & other having type ID with foreign key on delete CASCADE",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id", ConstraintName: getConstraintName("table2", "id"), OnDelete: "CASCADE"}, TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id", ConstraintName: getConstraintName("table2", "id"), OnDelete: "CASCADE"}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 2 fields 1 with type ID & other having type ID with index",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsIndex: true, Group: "group1", Order: 1, Sort: "asc"}}, TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsIndex: true, Group: "group1", Order: 1, Sort: "asc"}}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 3 fields 1 with type ID & other having type ID with index in group1",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsIndex: true, Group: "group1", Order: 1, Sort: "asc"}}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}, "col3": &model.FieldType{FieldName: "col3", IndexInfo: []*model.TableProperties{{IsIndex: true, Group: "group1", Order: 2, Sort: "asc"}}, TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsIndex: true, Group: "group1", Order: 1, Sort: "asc"}}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}, "col3": &model.FieldType{FieldName: "col3", IndexInfo: []*model.TableProperties{{IsIndex: true, Group: "group1", Order: 2, Sort: "asc"}}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 2 fields 1 with type ID & other having type ID with index",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsUnique: true, Group: "group1", Order: 1, Sort: "asc"}}, TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, TypeIDSize: model.SQLTypeIDSize}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsUnique: true, Group: "group1", Order: 1, Sort: "asc"}}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "Postgres no queries generated when both schemas have 3 fields 1 with type ID & other having type ID with index in group1",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsUnique: true, Group: "group1", Order: 1, Sort: "asc"}}, Kind: model.TypeID}, "col3": &model.FieldType{FieldName: "col3", IndexInfo: []*model.TableProperties{{IsUnique: true, Group: "group1", Order: 2, Sort: "asc"}}, TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"id": &model.FieldType{FieldName: "id", IsFieldTypeRequired: true, IsPrimary: true}}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", IndexInfo: []*model.TableProperties{{IsUnique: true, Group: "group1", Order: 1, Sort: "asc"}}, Kind: model.TypeID}, "col3": &model.FieldType{FieldName: "col3", IndexInfo: []*model.TableProperties{{IsUnique: true, Group: "group1", Order: 2, Sort: "asc"}}, Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "adding two columns",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{}},
			},
			isSort:  true,
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD COLUMN col1 varchar(50)", "ALTER TABLE test.table1 ADD COLUMN col2 text"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type integer",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (id varchar(50) NOT NULL , col1 bigint ,PRIMARY KEY (id));", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and a foreign key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeDateTime, Args: &model.FieldArgs{Scale: model.DefaultScale}, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col2"), To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (id varchar(50) NOT NULL , col2 timestamp ,PRIMARY KEY (id));", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col2 FOREIGN KEY (col2) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and a foreign key with ON CASCADE DELETE",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeDateTime, Args: &model.FieldArgs{Scale: model.DefaultScale}, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col2"), To: "id", OnDelete: "CASCADE"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (id varchar(50) NOT NULL , col2 timestamp ,PRIMARY KEY (id));", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col2 FOREIGN KEY (col2) REFERENCES test.table2 (id) ON DELETE CASCADE"},
			wantErr: false,
		},
		{
			name: "current Schema with NO ACTION and parsedSchema with ON CASCADE DELETE ",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id", OnDelete: "CASCADE"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP CONSTRAINT c_table1_col1", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id) ON DELETE CASCADE"},
			wantErr: false,
		},
		{
			name: "current Schema with CASCADE and parsedSchema with NO ACTION ",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id", OnDelete: "CASCADE"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP CONSTRAINT c_table1_col1", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type boolean",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", Kind: model.TypeBoolean, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (id varchar(50) NOT NULL , col1 boolean ,PRIMARY KEY (id));", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and a primary key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col3": &model.FieldType{FieldName: "col3", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: true, PrimaryKeyInfo: &model.TableProperties{}, IsPrimary: true}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col3 varchar(50) NOT NULL , PRIMARY KEY (col3));"},
			wantErr: false,
		},
		{
			name: "removing one column",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1"},
			wantErr: false,
		},
		{
			name: "required to unrequired",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: true}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ALTER COLUMN col1 SET NOT NULL"},
			wantErr: false,
		},
		{
			name: "unrequired to required",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: true}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ALTER COLUMN col1 DROP NOT NULL"},
			wantErr: false,
		},
		{
			name: "integer to JSON",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 jsonb"},
			wantErr: false,
		},
		{
			name: "JSON to integer",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 bigint"},
			wantErr: false,
		},
		{
			name: "JSON to string",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 text"},
			wantErr: false,
		},
		{
			name: "integer to string",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 text"},
			wantErr: false,
		},
		{
			name: "string to integer",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 bigint"},
			wantErr: false,
		},
		{
			name: "integer to float",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 float"},
			wantErr: false,
		},
		{
			name: "float to integer",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 bigint"},
			wantErr: false,
		},
		{
			name: "float to dateTime",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 timestamp"},
			wantErr: false,
		},
		{
			name: "datetime to float",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 float"},
			wantErr: false,
		},
		{
			name: "datetime to id",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 varchar(50)"},
			wantErr: false,
		},
		{
			name: "id to datetime",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 timestamp"},
			wantErr: false,
		},
		{
			name: "adding primary directive to type Json",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: true,
		},
		{
			name: "adding unique directive to type Json",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON, IsFieldTypeRequired: true, IndexInfo: []*model.TableProperties{{IsUnique: true}}}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: true,
		},
		{
			name: "adding index directive to type Json",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON, IsFieldTypeRequired: true, IndexInfo: []*model.TableProperties{{IsIndex: true}}}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: true,
		},
		{
			name: "mutating field with primary key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: true, IsDefault: true}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: true,
		},

		{
			name: "removing primary key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: false, IsPrimary: false}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: true, IsPrimary: true}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: true,
		},
		{
			name: "adding foreign key with type change",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsForeign: false}}, "table2": model.Fields{}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 bigint", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "removing foreign key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: false, IsForeign: false}}, "table2": model.Fields{"id": &model.FieldType{FieldName: "col1", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP CONSTRAINT c_table1_col1"},
			wantErr: false,
		},
		{
			name: "removing foreign key and type change",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: false, IsForeign: false}}, "table2": model.Fields{"id": &model.FieldType{FieldName: "col1", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", ConstraintName: getConstraintName("table1", "col1"), To: "id"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP CONSTRAINT c_table1_col1", "ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 bigint"},
			wantErr: false,
		},
		{
			name: "adding link",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsLinked: true, LinkedTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1"},
			wantErr: false,
		},
		{
			name: "removing link",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsFieldTypeRequired: false, IsForeign: false}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsLinked: true, LinkedTable: &model.TableProperties{Table: "table2", To: "id"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD COLUMN col1 varchar(50)"},
			wantErr: false,
		},
		{
			name: "Wrong dbAlias",
			args: args{
				dbAlias:       "wrgDbAlias",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{}}},
				currentSchema: model.Collection{"table1": model.Fields{}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			wantErr: true,
		},
		{
			name: "when table is not provided",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			wantErr: false,
		},
		{
			name: "tablename  present in currentschema but not in realschema",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			wantErr: true,
		},
		{
			name: "tablename  not present in currentschema, realschema",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			wantErr: false,
		},
		{
			name: "tablename  present in realschema but not in realschema",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"id": &model.FieldType{FieldName: "id", Kind: model.TypeID, TypeIDSize: model.SQLTypeIDSize, IsPrimary: true, PrimaryKeyInfo: &model.TableProperties{}, IsFieldTypeRequired: true}, "col1": &model.FieldType{FieldName: "col1", TypeIDSize: model.SQLTypeIDSize, Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (id varchar(50) NOT NULL , col1 varchar(50) ,PRIMARY KEY (id));"},
			wantErr: false,
		},
		{
			name: "fieldtype of type object in realschema",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeObject}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			wantErr: true,
		},
		{
			name: "invalid fieldtype in realschema and table not present in current schema",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeObject}}}},
				currentSchema: model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			wantErr: true,
		},
		{
			name: "invalid fieldtype in realschema",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgress": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: "int"}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeObject}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			wantErr: false,
		},
		{
			name: "adding index key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ALTER COLUMN col1 SET NOT NULL", "CREATE INDEX index__table1__ ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "adding index key to existing index",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 2, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD COLUMN col2 bigint", "DROP INDEX test.index__table1__i1", "CREATE INDEX index__table1__i1 ON test.table1 (col1 asc, col2 asc)"},
			wantErr: false,
		},
		{
			name: "doing nthg",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "doing nthg composite",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "adding new index key ",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, Group: "i2", Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD COLUMN col2 bigint", "CREATE INDEX index__table1__i2 ON test.table1 (col2 asc)"},
			wantErr: false,
		},
		{
			name: "adding unique key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IndexInfo: []*model.TableProperties{{Field: "col1", IsUnique: true, IsIndex: true, Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ALTER COLUMN col1 SET NOT NULL", "CREATE UNIQUE INDEX index__table1__ ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "adding unique index key to existing index",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 2, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD COLUMN col2 bigint", "DROP INDEX test.index__table1__i1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col1 asc, col2 asc)"},
			wantErr: false,
		},
		{
			name: "adding new unique index key ",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, Group: "i2", Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD COLUMN col2 bigint", "CREATE UNIQUE INDEX index__table1__i2 ON test.table1 (col2 asc)"},
			wantErr: false,
		},
		{
			name: "changing index to unique",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"DROP INDEX test.index__table1__i1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing index to unique",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"DROP INDEX test.index__table1__i1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing unique to index",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"DROP INDEX test.index__table1__i1", "CREATE INDEX index__table1__i1 ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing order of unique index key ",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 2, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 2, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"DROP INDEX test.index__table1__i1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col2 asc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing order of index key ",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 2, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 2, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"DROP INDEX test.index__table1__i1", "CREATE INDEX index__table1__i1 ON test.table1 (col2 asc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing group of unique index key ",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, ConstraintName: getIndexName("table1", "i2"), Group: "i2", Order: 2, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, ConstraintName: getIndexName("table1", "i2"), Group: "i2", Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 2, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"DROP INDEX test.index__table1__i1", "CREATE UNIQUE INDEX index__table1__i2 ON test.table1 (col2 asc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing qroup of index key ",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, ConstraintName: getIndexName("table1", "i2"), Group: "i2", Order: 2, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, ConstraintName: getIndexName("table1", "i2"), Group: "i2", Order: 1, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 2, IsIndex: true}}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"DROP INDEX test.index__table1__i1", "CREATE INDEX index__table1__i2 ON test.table1 (col2 asc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing sort of unique index key ",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 2, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 1, Sort: "desc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 1, Sort: "desc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 2, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"DROP INDEX test.index__table1__i1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col2 desc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing column type of single field unique index",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 2, Sort: "desc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString, IndexInfo: []*model.TableProperties{{IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 1, Sort: "desc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, IsUnique: true, Group: "i1", ConstraintName: getIndexName("table1", "i1"), Order: 2, Sort: "asc"}}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"DROP INDEX test.index__table1__i1", "ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 bigint", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col1 asc, col2 desc)"},
			wantErr: false,
		},
		{
			name: "changing sort of index key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 1, Sort: "asc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 2, Sort: "asc"}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col1", IsIndex: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 1, Sort: "desc"}}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IndexInfo: []*model.TableProperties{{Field: "col2", IsIndex: true, ConstraintName: getIndexName("table1", "i1"), Group: "i1", Order: 2, Sort: "desc"}}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"DROP INDEX test.index__table1__i1", "CREATE INDEX index__table1__i1 ON test.table1 (col1 asc, col2 asc)"},
			wantErr: false,
		},
		{
			name: "adding invalid order key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IndexInfo: []*model.TableProperties{{IsIndex: true, Order: 2}}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := &Schema{
				SchemaDoc: tt.fields.SchemaDoc,
				crud:      tt.fields.crud,
				project:   tt.fields.project,
				dbSchemas: tt.fields.config,
			}
			got, err := s.generateCreationQueries(context.Background(), tt.args.dbAlias, tt.args.tableName, tt.args.project, tt.args.parsedSchema, tt.args.currentSchema)
			if (err != nil) != tt.wantErr {
				t.Errorf("dbAlias : %v name = %v, Schema.generateCreationQueries()\n error = %v,\n wantErr %v", tt.args.dbAlias, tt.name, err, tt.wantErr)
				return
			}

			if !tt.wantErr {
				if len(got) != len(tt.want) {
					t.Errorf("dbAlias : %v Schema.generateCreationQueries() length error:\n got = %v,\n want = %v", tt.args.dbAlias, got, tt.want)
					return
				}
				if tt.isSort {
					got = sortArray(got)
					tt.want = sortArray(tt.want)
				}
				for i, v := range got {
					if tt.want[i] != v {
						t.Errorf("dbAlias : %v Schema.generateCreationQueries()\n got = %v,\n want %v", tt.args.dbAlias, got, tt.want)
						return
					}
				}
			}
		})
	}
}

func sortArray(a []string) []string {
	l := len(a)
	for i := 0; i < l; i++ {
		for j := i; j < l; j++ {
			if a[i] > a[j] {
				a[i], a[j] = a[j], a[i]
			}
		}
	}
	return a
}
