package schema

import (
	"context"
	"log"
	"testing"

	"github.com/spaceuptech/space-cloud/gateway/config"
	"github.com/spaceuptech/space-cloud/gateway/model"
	"github.com/spaceuptech/space-cloud/gateway/modules/crud"
)

func TestSchema_generateCreationQueries(t *testing.T) {
	type fields struct {
		SchemaDoc          model.Type
		crud               model.CrudSchemaInterface
		project            string
		config             config.Crud
		removeProjectScope bool
	}
	type args struct {
		ctx           context.Context
		dbAlias       string
		tableName     string
		project       string
		parsedSchema  model.Type
		currentSchema model.Collection
	}

	crudPostgres := crud.Init(false)
	_ = crudPostgres.SetConfig("test", config.Crud{"postgres": {Type: "sql-postgres", Enabled: false}})

	crudMySQL := crud.Init(false)
	_ = crudMySQL.SetConfig("test", config.Crud{"mysql": {Type: "sql-mysql", Enabled: false}})

	crudSQLServer := crud.Init(false)
	_ = crudSQLServer.SetConfig("test", config.Crud{"sqlserver": {Type: "sql-sqlserver", Enabled: false}})

	tests := []struct {
		name    string
		fields  fields
		args    args
		want    []string
		isSort  bool
		wantErr bool
	}{
		{
			name: "adding a table and column of type JSON",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON, IsFieldTypeRequired: true}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 json NOT NULL );"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type integer with default key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IsDefault: true, Default: 543}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 bigint NOT NULL );", "ALTER TABLE test.table1 ALTER col1 SET DEFAULT 543"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type float with default key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat, IsFieldTypeRequired: true, IsDefault: true, Default: 5.2}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 float NOT NULL );", "ALTER TABLE test.table1 ALTER col1 SET DEFAULT 5.2"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type string with default key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString, IsFieldTypeRequired: true, IsDefault: true, Default: "string"}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 text NOT NULL );", "ALTER TABLE test.table1 ALTER col1 SET DEFAULT 'string'"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type boolean with default key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeBoolean, IsFieldTypeRequired: true, IsDefault: true, Default: true}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 boolean NOT NULL );", "ALTER TABLE test.table1 ALTER col1 SET DEFAULT true"},
			wantErr: false,
		},
		{
			name: "removing a table and column of type boolean with default key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeBoolean}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeBoolean, IsDefault: true, Default: true}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ALTER col1 DROP DEFAULT"},
			wantErr: false,
		},
		{
			name: "adding two columns",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{}},
			},
			isSort:  true,
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD col1 varchar(50)", "ALTER TABLE test.table1 ADD col2 text"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type integer",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 bigint );", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and a foreign key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col2": &model.FieldType{FieldName: "col2", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col2 datetime );", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col2 FOREIGN KEY (col2) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and a foreign key with ON DELETE CASCADE",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col2": &model.FieldType{FieldName: "col2", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id", OnDelete: "CASCADE"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col2 datetime );", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col2 FOREIGN KEY (col2) REFERENCES test.table2 (id) ON DELETE CASCADE"},
			wantErr: false,
		},
		{
			name: "current Schema with NO ACTION and parsedSchema with ON CASCADE DELETE ",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id", OnDelete: "CASCADE"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP FOREIGN KEY c_table1_col1", "ALTER TABLE test.table1 DROP INDEX c_table1_col1", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id) ON DELETE CASCADE"},
			wantErr: false,
		},
		{
			name: "current Schema with CASCADE and parsedSchema with NO ACTION ",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id", OnDelete: "CASCADE"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP FOREIGN KEY c_table1_col1", "ALTER TABLE test.table1 DROP INDEX c_table1_col1", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type boolean",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeBoolean, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 boolean );", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and a primary key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col3": &model.FieldType{FieldName: "col3", Kind: model.TypeID, IsFieldTypeRequired: true, IsPrimary: true}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col3 varchar(50) PRIMARY KEY NOT NULL );"},
			wantErr: false,
		},
		{
			name: "changing type of column with primary key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col3": &model.FieldType{FieldName: "col3", Kind: model.TypeID, IsFieldTypeRequired: true, IsPrimary: true}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col3": &model.FieldType{FieldName: "col3", Kind: model.TypeInteger, IsFieldTypeRequired: true, IsPrimary: true}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP PRIMARY KEY", "ALTER TABLE test.table1 DROP COLUMN col3", "ALTER TABLE test.table1 ADD col3 varchar(50)", "ALTER TABLE test.table1 MODIFY col3 varchar(50) NOT NULL", "ALTER TABLE test.table1 ADD PRIMARY KEY (col3)"},
			wantErr: false,
		},
		{
			name: "removing one column",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1"},
			wantErr: false,
		},
		{
			name: "required to unrequired",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsFieldTypeRequired: true}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 MODIFY col1 varchar(50) NOT NULL"},
			wantErr: false,
		},
		{
			name: "unrequired to required",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsFieldTypeRequired: true}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 MODIFY col1 varchar(50) NULL"},
			wantErr: false,
		},
		{
			name: "integer to JSON",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 json"},
			wantErr: false,
		},
		{
			name: "JSON to integer",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 bigint"},
			wantErr: false,
		},
		{
			name: "JSON to string",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 text"},
			wantErr: false,
		},
		{
			name: "integer to string",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 text"},
			wantErr: false,
		},
		{
			name: "string to integer",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 bigint"},
			wantErr: false,
		},
		{
			name: "integer to float",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 float"},
			wantErr: false,
		},
		{
			name: "float to integer",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 bigint"},
			wantErr: false,
		},
		{
			name: "float to dateTime",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 datetime"},
			wantErr: false,
		},
		{
			name: "datetime to float",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 float"},
			wantErr: false,
		},
		{
			name: "datetime to id",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 varchar(50)"},
			wantErr: false,
		},
		{
			name: "id to datetime",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 datetime"},
			wantErr: false,
		},
		{
			name: "adding primary directive to type Json",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON, IsPrimary: true, IsFieldTypeRequired: true}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: true,
		},
		{
			name: "adding unique directive to type Json",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON, IsFieldTypeRequired: true, IsUnique: true}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: true,
		},
		{
			name: "adding index directive to type Json",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON, IsFieldTypeRequired: true, IsIndex: true}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: true,
		},
		{
			name: "adding primary key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsFieldTypeRequired: true, IsPrimary: true}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsPrimary: false}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 MODIFY col1 varchar(50) NOT NULL", "ALTER TABLE test.table1 ADD PRIMARY KEY (col1)"},
			wantErr: false,
		},
		{
			name: "removing primary key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsFieldTypeRequired: false, IsPrimary: false}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsFieldTypeRequired: true, IsPrimary: true}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 MODIFY col1 varchar(50) NULL", "ALTER TABLE test.table1 DROP PRIMARY KEY"},
			wantErr: false,
		},
		{
			name: "adding foreign key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsForeign: false}}, "table2": model.Fields{}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding foreign key with type change",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsForeign: false}}, "table2": model.Fields{}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 bigint", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "removing foreign key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsFieldTypeRequired: false, IsForeign: false}}, "table2": model.Fields{"id": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP FOREIGN KEY c_table1_col1", "ALTER TABLE test.table1 DROP INDEX c_table1_col1"},
			wantErr: false,
		},
		{
			name: "removing foreign key and type change",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: false, IsForeign: false}}, "table2": model.Fields{"id": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP FOREIGN KEY c_table1_col1", "ALTER TABLE test.table1 DROP INDEX c_table1_col1", "ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 bigint"},
			wantErr: false,
		},
		{
			name: "adding link",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsLinked: true, LinkedTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1"},
			wantErr: false,
		},
		{
			name: "removing link",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsFieldTypeRequired: false, IsForeign: false}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsLinked: true, LinkedTable: &model.TableProperties{Table: "table2", To: "id"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD col1 varchar(50)"},
			wantErr: false,
		},
		{
			name: "Wrong dbAlias",
			args: args{
				dbAlias:       "wrgDbAlias",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{}}},
				currentSchema: model.Collection{"table1": model.Fields{}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			wantErr: true,
		},
		{
			name: "when table is not provided",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			wantErr: false,
		},
		{
			name: "tablename  present in currentschema but not in realschema",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			wantErr: true,
		},
		{
			name: "tablename  not present in currentschema, realschema",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			wantErr: false,
		},
		{
			name: "tablename  present in realschema but not in realschema",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 varchar(50) );"},
			wantErr: false,
		},
		{
			name: "fieldtype of type object in realschema",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeObject}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			wantErr: true,
		},
		{
			name: "invalid fieldtype in realschema and table not present in current schema",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeObject}}}},
				currentSchema: model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			wantErr: true,
		},
		{
			name: "invalid fieldtype in realschema",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: "int"}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeObject}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			wantErr: true,
		},
		{
			name: "doing nthg",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "doing nthg composite",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "adding index key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IsIndex: true, IndexInfo: &model.TableProperties{Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 MODIFY col1 bigint NOT NULL", "CREATE INDEX index__table1__ ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "adding index key to existing index",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD col2 bigint", "DROP INDEX index__table1__i1 ON test.table1", "CREATE INDEX index__table1__i1 ON test.table1 (col1 asc, col2 asc)"},
			wantErr: false,
		},
		{
			name: "adding new index key ",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i2", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD col2 bigint", "CREATE INDEX index__table1__i2 ON test.table1 (col2 asc)"},
			wantErr: false,
		},
		{
			name: "adding unique key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IsUnique: true, IsIndex: true, IndexInfo: &model.TableProperties{Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 MODIFY col1 bigint NOT NULL", "CREATE UNIQUE INDEX index__table1__ ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "adding unique index key to existing index",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD col2 bigint", "DROP INDEX index__table1__i1 ON test.table1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col1 asc, col2 asc)"},
			wantErr: false,
		},
		{
			name: "adding new unique index key ",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i2", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD col2 bigint", "CREATE UNIQUE INDEX index__table1__i2 ON test.table1 (col2 asc)"},
			wantErr: false,
		},
		{
			name: "changing index to unique",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON test.table1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing unique to index",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON test.table1", "CREATE INDEX index__table1__i1 ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing order of unique index key ",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON test.table1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col2 asc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing order of index key ",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON test.table1", "CREATE INDEX index__table1__i1 ON test.table1 (col2 asc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing group of unique index key ",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i2", Order: 2, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i2", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE UNIQUE INDEX index__table1__i2 ON test.table1 (col2 asc, col1 asc)", "DROP INDEX index__table1__i1 ON test.table1"},
			wantErr: false,
		},
		{
			name: "changing qroup of index key ",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i2", Order: 2, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i2", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"CREATE INDEX index__table1__i2 ON test.table1 (col2 asc, col1 asc)", "DROP INDEX index__table1__i1 ON test.table1"},
			wantErr: false,
		},
		{
			name: "changing sort of unique index key ",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "desc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "desc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON test.table1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col2 desc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing sort of index key ",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "desc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "desc"}}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON test.table1", "CREATE INDEX index__table1__i1 ON test.table1 (col1 asc, col2 asc)"},
			wantErr: false,
		},
		{
			name: "adding invalid order key",
			args: args{
				dbAlias:       "mysql",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"mysql": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IsIndex: true, IndexInfo: &model.TableProperties{Order: 2}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudMySQL, project: "test"},
			wantErr: true,
		},

		// //sql-server
		{
			name: "adding a table and column of type JSON",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON, IsFieldTypeRequired: true}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: true,
		},
		{
			name: "adding a table and column of type integer with default key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IsDefault: true, Default: 543}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 bigint NOT NULL );", "ALTER TABLE test.table1 ADD CONSTRAINT c_col1 DEFAULT 543 FOR col1"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type float with default key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat, IsFieldTypeRequired: true, IsDefault: true, Default: 5.2}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 float NOT NULL );", "ALTER TABLE test.table1 ADD CONSTRAINT c_col1 DEFAULT 5.2 FOR col1"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type string with default key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString, IsFieldTypeRequired: true, IsDefault: true, Default: "string"}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 varchar(max) NOT NULL );", "ALTER TABLE test.table1 ADD CONSTRAINT c_col1 DEFAULT 'string' FOR col1"},
			wantErr: false,
		},
		{
			name: "removing a table and column of type boolean with default key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeBoolean}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeBoolean, IsDefault: true, Default: true}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP CONSTRAINT c_col1"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type boolean with default key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeBoolean, IsFieldTypeRequired: true, IsDefault: true, Default: true}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 bit NOT NULL );", "ALTER TABLE test.table1 ADD CONSTRAINT c_col1 DEFAULT 1 FOR col1"},
			wantErr: false,
		},
		{
			name: "adding two columns",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{}},
			},
			isSort:  true,
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD col1 varchar(50)", "ALTER TABLE test.table1 ADD col2 varchar(max)"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type integer",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 bigint );", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and a foreign key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col2": &model.FieldType{FieldName: "col2", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col2 timestamp );", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col2 FOREIGN KEY (col2) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and a foreign key with ON DELETE CASCADE",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col2": &model.FieldType{FieldName: "col2", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id", OnDelete: "CASCADE"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col2 timestamp );", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col2 FOREIGN KEY (col2) REFERENCES test.table2 (id) ON DELETE CASCADE"},
			wantErr: false,
		},
		{
			name: "current Schema with NO ACTION and parsedSchema with ON CASCADE DELETE ",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id", OnDelete: "CASCADE"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP CONSTRAINT c_table1_col1", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id) ON DELETE CASCADE"},
			wantErr: false,
		},
		{
			name: "current Schema with CASCADE and parsedSchema with NO ACTION ",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id", OnDelete: "CASCADE"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP CONSTRAINT c_table1_col1", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type boolean",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeBoolean, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 bit );", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and a primary key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col3": &model.FieldType{FieldName: "col3", Kind: model.TypeID, IsFieldTypeRequired: true, IsPrimary: true}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col3 varchar(50) PRIMARY KEY NOT NULL );"},
			wantErr: false,
		},
		{
			name: "removing one column",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1"},
			wantErr: false,
		},
		{
			name: "required to unrequired",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsFieldTypeRequired: true}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ALTER COLUMN col1 varchar(50) NOT NULL"},
			wantErr: false,
		},
		{
			name: "unrequired to required",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsFieldTypeRequired: true}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ALTER COLUMN col1 varchar(50) NULL"},
			wantErr: false,
		},
		{
			name: "integer to string",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 varchar(max)"},
			wantErr: false,
		},
		{
			name: "string to integer",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 bigint"},
			wantErr: false,
		},
		{
			name: "integer to float",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 float"},
			wantErr: false,
		},
		{
			name: "float to integer",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 bigint"},
			wantErr: false,
		},
		{
			name: "float to dateTime",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 timestamp NULL"},
			wantErr: false,
		},
		{
			name: "datetime to float",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 float"},
			wantErr: false,
		},
		{
			name: "datetime to id",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 varchar(50)"},
			wantErr: false,
		},
		{
			name: "id to datetime",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 timestamp NULL"},
			wantErr: false,
		},
		{
			name: "adding primary key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsFieldTypeRequired: true, IsPrimary: true}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsPrimary: false}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ALTER COLUMN col1 varchar(50) NOT NULL", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 PRIMARY KEY CLUSTERED (col1)"},
			wantErr: false,
		},
		{
			name: "removing primary key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsFieldTypeRequired: false, IsPrimary: false}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsFieldTypeRequired: true, IsPrimary: true}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ALTER COLUMN col1 varchar(50) NULL", "ALTER TABLE test.table1 DROP CONSTRAINT c_table1_col1"},
			wantErr: false,
		},
		{
			name: "adding foreign key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsForeign: false}}, "table2": model.Fields{}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding foreign key with type change",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsForeign: false}}, "table2": model.Fields{}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 bigint", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "removing foreign key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsFieldTypeRequired: false, IsForeign: false}}, "table2": model.Fields{"id": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP CONSTRAINT c_table1_col1"},
			wantErr: false,
		},
		{
			name: "removing foreign key and type change",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: false, IsForeign: false}}, "table2": model.Fields{"id": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP CONSTRAINT c_table1_col1", "ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD col1 bigint"},
			wantErr: false,
		},
		{
			name: "adding link",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsLinked: true, LinkedTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1"},
			wantErr: false,
		},
		{
			name: "removing link",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsFieldTypeRequired: false, IsForeign: false}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsLinked: true, LinkedTable: &model.TableProperties{Table: "table2", To: "id"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD col1 varchar(50)"},
			wantErr: false,
		},
		{
			name: "Wrong dbAlias",
			args: args{
				dbAlias:       "wrgDbAlias",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{}}},
				currentSchema: model.Collection{"table1": model.Fields{}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			wantErr: true,
		},
		{
			name: "when table is not provided",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			wantErr: false,
		},
		{
			name: "tablename  present in currentschema but not in realschema",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			wantErr: true,
		},
		{
			name: "tablename  not present in currentschema, realschema",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			wantErr: false,
		},
		{
			name: "tablename  present in realschema but not in realschema",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 varchar(50) );"},
			wantErr: false,
		},
		{
			name: "fieldtype of type object in realschema",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeObject}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			wantErr: true,
		},
		{
			name: "invalid fieldtype in realschema and table not present in current schema",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeObject}}}},
				currentSchema: model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			wantErr: true,
		},
		{
			name: "invalid fieldtype in realschema",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: "int"}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeObject}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			wantErr: true,
		},
		{
			name: "adding a table and column of type JSON",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON, IsFieldTypeRequired: true}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 jsonb NOT NULL );"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type integer with default key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IsDefault: true, Default: 543}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 bigint NOT NULL );", "ALTER TABLE test.table1 ALTER COLUMN col1 SET DEFAULT 543"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type float with default key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat, IsFieldTypeRequired: true, IsDefault: true, Default: 5.2}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 float NOT NULL );", "ALTER TABLE test.table1 ALTER COLUMN col1 SET DEFAULT 5.2"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type string with default key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString, IsFieldTypeRequired: true, IsDefault: true, Default: "string"}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 text NOT NULL );", "ALTER TABLE test.table1 ALTER COLUMN col1 SET DEFAULT 'string'"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type boolean with default key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeBoolean, IsFieldTypeRequired: true, IsDefault: true, Default: true}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 boolean NOT NULL );", "ALTER TABLE test.table1 ALTER COLUMN col1 SET DEFAULT true"},
			wantErr: false,
		},
		{
			name: "adding two columns",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IsIndex: true, IndexInfo: &model.TableProperties{Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			isSort:  true,
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ALTER COLUMN col1 bigint NOT NULL", "CREATE INDEX index__table1__ ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "doing nthg",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "doing nthg composite",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "adding index key to existing index",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD col2 bigint", "DROP INDEX index__table1__i1 ON test.table1", "CREATE INDEX index__table1__i1 ON test.table1 (col1 asc, col2 asc)"},
			wantErr: false,
		},
		{
			name: "adding new index key ",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i2", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD col2 bigint", "CREATE INDEX index__table1__i2 ON test.table1 (col2 asc)"},
			wantErr: false,
		},
		{
			name: "adding unique key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IsUnique: true, IsIndex: true, IndexInfo: &model.TableProperties{Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ALTER COLUMN col1 bigint NOT NULL", "CREATE UNIQUE INDEX index__table1__ ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "adding unique index key to existing index",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD col2 bigint", "DROP INDEX index__table1__i1 ON test.table1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col1 asc, col2 asc)"},
			wantErr: false,
		},
		{
			name: "adding new unique index key ",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i2", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD col2 bigint", "CREATE UNIQUE INDEX index__table1__i2 ON test.table1 (col2 asc)"},
			wantErr: false,
		},
		{
			name: "changing index to unique",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON test.table1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing index to unique",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON test.table1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing unique to index",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON test.table1", "CREATE INDEX index__table1__i1 ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing order of unique index key ",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON test.table1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col2 asc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing order of index key ",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON test.table1", "CREATE INDEX index__table1__i1 ON test.table1 (col2 asc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing group of unique index key ",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i2", Order: 2, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i2", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE UNIQUE INDEX index__table1__i2 ON test.table1 (col2 asc, col1 asc)", "DROP INDEX index__table1__i1 ON test.table1"},
			wantErr: false,
		},
		{
			name: "changing qroup of index key ",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i2", Order: 2, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i2", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"CREATE INDEX index__table1__i2 ON test.table1 (col2 asc, col1 asc)", "DROP INDEX index__table1__i1 ON test.table1"},
			wantErr: false,
		},
		{
			name: "changing sort of unique index key ",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "desc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "desc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON test.table1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col2 desc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing sort of index key ",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "desc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "desc"}}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			want:    []string{"DROP INDEX index__table1__i1 ON test.table1", "CREATE INDEX index__table1__i1 ON test.table1 (col1 asc, col2 asc)"},
			wantErr: false,
		},
		{
			name: "adding invalid order key",
			args: args{
				dbAlias:       "sqlserver",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"sqlserver": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IsIndex: true, IndexInfo: &model.TableProperties{Order: 2}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudSQLServer, project: "test"},
			wantErr: true,
		},

		// //postgres
		{
			name: "adding two columns",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{}},
			},
			isSort:  true,
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD COLUMN col1 varchar(50)", "ALTER TABLE test.table1 ADD COLUMN col2 text"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type integer",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 bigint );", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and a foreign key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col2": &model.FieldType{FieldName: "col2", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col2 timestamp );", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col2 FOREIGN KEY (col2) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and a foreign key with ON CASCADE DELETE",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col2": &model.FieldType{FieldName: "col2", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id", OnDelete: "CASCADE"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col2 timestamp );", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col2 FOREIGN KEY (col2) REFERENCES test.table2 (id) ON DELETE CASCADE"},
			wantErr: false,
		},
		{
			name: "current Schema with NO ACTION and parsedSchema with ON CASCADE DELETE ",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id", OnDelete: "CASCADE"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP CONSTRAINT c_table1_col1", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id) ON DELETE CASCADE"},
			wantErr: false,
		},
		{
			name: "current Schema with CASCADE and parsedSchema with NO ACTION ",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}, "table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id", OnDelete: "CASCADE"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP CONSTRAINT c_table1_col1", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and column of type boolean",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeBoolean, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 boolean );", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "adding a table and a primary key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col3": &model.FieldType{FieldName: "col3", Kind: model.TypeID, IsFieldTypeRequired: true, IsPrimary: true}}}},
				currentSchema: model.Collection{"table2": model.Fields{}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col3 varchar(50) PRIMARY KEY NOT NULL );"},
			wantErr: false,
		},
		{
			name: "removing one column",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1"},
			wantErr: false,
		},
		{
			name: "required to unrequired",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsFieldTypeRequired: true}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ALTER COLUMN col1 SET NOT NULL"},
			wantErr: false,
		},
		{
			name: "unrequired to required",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsFieldTypeRequired: true}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ALTER COLUMN col1 DROP NOT NULL"},
			wantErr: false,
		},
		{
			name: "integer to JSON",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 jsonb"},
			wantErr: false,
		},
		{
			name: "JSON to integer",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 bigint"},
			wantErr: false,
		},
		{
			name: "JSON to string",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 text"},
			wantErr: false,
		},
		{
			name: "integer to string",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 text"},
			wantErr: false,
		},
		{
			name: "string to integer",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 bigint"},
			wantErr: false,
		},
		{
			name: "integer to float",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 float"},
			wantErr: false,
		},
		{
			name: "float to integer",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 bigint"},
			wantErr: false,
		},
		{
			name: "float to dateTime",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 timestamp"},
			wantErr: false,
		},
		{
			name: "datetime to float",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeFloat}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 float"},
			wantErr: false,
		},
		{
			name: "datetime to id",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 varchar(50)"},
			wantErr: false,
		},
		{
			name: "id to datetime",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeDateTime}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 timestamp"},
			wantErr: false,
		},
		{
			name: "adding primary directive to type Json",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON, IsPrimary: true, IsFieldTypeRequired: true}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: true,
		},
		{
			name: "adding unique directive to type Json",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON, IsFieldTypeRequired: true, IsUnique: true}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: true,
		},
		{
			name: "adding index directive to type Json",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeJSON, IsFieldTypeRequired: true, IsIndex: true}}}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: true,
		},
		{
			name: "adding primary key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsFieldTypeRequired: true, IsPrimary: true}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsPrimary: false}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ALTER COLUMN col1 SET NOT NULL", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 PRIMARY KEY (col1)"},
			wantErr: false,
		},

		{
			name: "removing primary key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsFieldTypeRequired: false, IsPrimary: false}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsFieldTypeRequired: true, IsPrimary: true}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ALTER COLUMN col1 DROP NOT NULL", "ALTER TABLE test.table1 DROP CONSTRAINT c_table1_col1"},
			wantErr: false,
		},
		{
			name: "adding foreign key with type change",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsForeign: false}}, "table2": model.Fields{}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 bigint", "ALTER TABLE test.table1 ADD CONSTRAINT c_table1_col1 FOREIGN KEY (col1) REFERENCES test.table2 (id)"},
			wantErr: false,
		},
		{
			name: "removing foreign key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsFieldTypeRequired: false, IsForeign: false}}, "table2": model.Fields{"id": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP CONSTRAINT c_table1_col1"},
			wantErr: false,
		},
		{
			name: "removing foreign key and type change",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: false, IsForeign: false}}, "table2": model.Fields{"id": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsForeign: true, JointTable: &model.TableProperties{Table: "table2", To: "id"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP CONSTRAINT c_table1_col1", "ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 bigint"},
			wantErr: false,
		},
		{
			name: "adding link",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsLinked: true, LinkedTable: &model.TableProperties{Table: "table2", To: "id"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 DROP COLUMN col1"},
			wantErr: false,
		},
		{
			name: "removing link",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsFieldTypeRequired: false, IsForeign: false}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID, IsLinked: true, LinkedTable: &model.TableProperties{Table: "table2", To: "id"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD COLUMN col1 varchar(50)"},
			wantErr: false,
		},
		{
			name: "Wrong dbAlias",
			args: args{
				dbAlias:       "wrgDbAlias",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{}}},
				currentSchema: model.Collection{"table1": model.Fields{}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			wantErr: true,
		},
		{
			name: "when table is not provided",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{}},
				currentSchema: model.Collection{},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			wantErr: false,
		},
		{
			name: "tablename  present in currentschema but not in realschema",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			wantErr: true,
		},
		{
			name: "tablename  not present in currentschema, realschema",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			wantErr: false,
		},
		{
			name: "tablename  present in realschema but not in realschema",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeID}}}},
				currentSchema: model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE TABLE test.table1 (col1 varchar(50) );"},
			wantErr: false,
		},
		{
			name: "fieldtype of type object in realschema",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeObject}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			wantErr: true,
		},
		{
			name: "invalid fieldtype in realschema and table not present in current schema",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeObject}}}},
				currentSchema: model.Collection{"table2": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			wantErr: true,
		},
		{
			name: "invalid fieldtype in realschema",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgress": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: "int"}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeObject}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			wantErr: false,
		},
		{
			name: "adding index key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IsIndex: true, IndexInfo: &model.TableProperties{Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ALTER COLUMN col1 SET NOT NULL", "CREATE INDEX index__table1__ ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "adding index key to existing index",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD COLUMN col2 bigint", "DROP INDEX test.index__table1__i1", "CREATE INDEX index__table1__i1 ON test.table1 (col1 asc, col2 asc)"},
			wantErr: false,
		},
		{
			name: "doing nthg",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "doing nthg composite",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{},
			wantErr: false,
		},
		{
			name: "adding new index key ",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i2", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD COLUMN col2 bigint", "CREATE INDEX index__table1__i2 ON test.table1 (col2 asc)"},
			wantErr: false,
		},
		{
			name: "adding unique key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IsUnique: true, IsIndex: true, IndexInfo: &model.TableProperties{Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ALTER COLUMN col1 SET NOT NULL", "CREATE UNIQUE INDEX index__table1__ ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "adding unique index key to existing index",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD COLUMN col2 bigint", "DROP INDEX test.index__table1__i1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col1 asc, col2 asc)"},
			wantErr: false,
		},
		{
			name: "adding new unique index key ",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i2", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"ALTER TABLE test.table1 ADD COLUMN col2 bigint", "CREATE UNIQUE INDEX index__table1__i2 ON test.table1 (col2 asc)"},
			wantErr: false,
		},
		{
			name: "changing index to unique",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"DROP INDEX test.index__table1__i1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing index to unique",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"DROP INDEX test.index__table1__i1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing unique to index",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"DROP INDEX test.index__table1__i1", "CREATE INDEX index__table1__i1 ON test.table1 (col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing order of unique index key ",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"DROP INDEX test.index__table1__i1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col2 asc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing order of index key ",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"DROP INDEX test.index__table1__i1", "CREATE INDEX index__table1__i1 ON test.table1 (col2 asc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing group of unique index key ",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i2", Order: 2, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i2", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE UNIQUE INDEX index__table1__i2 ON test.table1 (col2 asc, col1 asc)", "DROP INDEX test.index__table1__i1"},
			wantErr: false,
		},
		{
			name: "changing qroup of index key ",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i2", Order: 2, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i2", Order: 1, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"CREATE INDEX index__table1__i2 ON test.table1 (col2 asc, col1 asc)", "DROP INDEX test.index__table1__i1"},
			wantErr: false,
		},
		{
			name: "changing sort of unique index key ",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "desc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "desc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"DROP INDEX test.index__table1__i1", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col2 desc, col1 asc)"},
			wantErr: false,
		},
		{
			name: "changing column type of single field unique index",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "desc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeString, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "desc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IsUnique: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"DROP INDEX test.index__table1__i1", "ALTER TABLE test.table1 DROP COLUMN col1", "ALTER TABLE test.table1 ADD COLUMN col1 bigint", "CREATE UNIQUE INDEX index__table1__i1 ON test.table1 (col1 asc, col2 desc)"},
			wantErr: false,
		},
		{
			name: "changing sort of index key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "asc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "asc"}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 1, Sort: "desc"}}, "col2": &model.FieldType{FieldName: "col2", Kind: model.TypeInteger, IsIndex: true, IndexInfo: &model.TableProperties{Group: "i1", Order: 2, Sort: "desc"}}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			want:    []string{"DROP INDEX test.index__table1__i1", "CREATE INDEX index__table1__i1 ON test.table1 (col1 asc, col2 asc)"},
			wantErr: false,
		},
		{
			name: "adding invalid order key",
			args: args{
				dbAlias:       "postgres",
				tableName:     "table1",
				project:       "test",
				parsedSchema:  model.Type{"postgres": model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger, IsFieldTypeRequired: true, IsIndex: true, IndexInfo: &model.TableProperties{Order: 2}}}}},
				currentSchema: model.Collection{"table1": model.Fields{"col1": &model.FieldType{FieldName: "col1", Kind: model.TypeInteger}}},
			},
			fields:  fields{crud: crudPostgres, project: "test"},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := &Schema{
				SchemaDoc:          tt.fields.SchemaDoc,
				crud:               tt.fields.crud,
				project:            tt.fields.project,
				config:             tt.fields.config,
				removeProjectScope: tt.fields.removeProjectScope,
			}
			got, err := s.generateCreationQueries(tt.args.ctx, tt.args.dbAlias, tt.args.tableName, tt.args.project, tt.args.parsedSchema, tt.args.currentSchema)
			if (err != nil) != tt.wantErr {
				t.Errorf("name = %v, Schema.generateCreationQueries() error = %v, wantErr %v", tt.name, err, tt.wantErr)
				return
			}

			if !tt.wantErr {
				if len(got) != len(tt.want) {
					t.Errorf("Schema.generateCreationQueries() length error: got = %v, want = %v", got, tt.want)
					return
				}
				if tt.isSort {
					got = sortArray(got)
					tt.want = sortArray(tt.want)
				}
				for i, v := range got {
					if tt.want[i] != v {
						log.Println("sort:", tt.isSort)
						t.Errorf("Schema.generateCreationQueries() = %v, want %v", got, tt.want)
						return
					}
				}
			}
		})
	}
}

func sortArray(a []string) []string {
	l := len(a)
	for i := 0; i < l; i++ {
		for j := i; j < l; j++ {
			if a[i] > a[j] {
				a[i], a[j] = a[j], a[i]
			}
		}
	}
	return a
}
