package openapi

import (
	"encoding/json"
	"net/http"
	"net/url"
	"strconv"

	"github.com/caddyserver/caddy/v2"
	"github.com/getkin/kin-openapi/openapi3"
	"go.uber.org/zap"
	"k8s.io/apimachinery/pkg/runtime/schema"

	"github.com/mitchellh/mapstructure"
	"github.com/spacecloud-io/space-cloud/managers/source"
	"github.com/spacecloud-io/space-cloud/modules/rpc"
	"github.com/spacecloud-io/space-cloud/pkg/apis/core/v1alpha1"
)

var openapisourcesResource = schema.GroupVersionResource{Group: "core.space-cloud.io", Version: "v1alpha1", Resource: "openapisources"}

func init() {
	source.RegisterSource(Source{}, openapisourcesResource)
}

// Source describes the compiled openapi
type Source struct {
	v1alpha1.OpenAPISource

	// Internal stuff
	logger *zap.Logger
}

// CaddyModule returns the Caddy module information.
func (Source) CaddyModule() caddy.ModuleInfo {
	return caddy.ModuleInfo{
		ID:  caddy.ModuleID(source.GetModuleName(openapisourcesResource)),
		New: func() caddy.Module { return new(Source) },
	}
}

// Provision provisions the source
func (s *Source) Provision(ctx caddy.Context) error {
	s.logger = ctx.Logger(s)

	return nil
}

// GetPriority returns the priority of the source. Higher
func (s *Source) GetPriority() int {
	return 0
}

// GetProviders returns the providers this source is applicable for
func (s *Source) GetProviders() []string {
	return []string{"rpc"}
}

// GetRPCs returns the rpcs generated by the openapi spec
func (s *Source) GetRPCs() rpc.RPCs {
	loader := openapi3.NewLoader()
	var schema *openapi3.T

	if s.Spec.OpenAPI.Ref != nil {
		// Load the OpenAPI specification from URL
		url, err := url.Parse(s.Spec.OpenAPI.Ref.URL)
		if err != nil {
			s.logger.Error("Unable to parse URL to load OpenAPI spec", zap.Error(err))
			return nil
		}
		schema, err = loader.LoadFromURI(url)
		if err != nil {
			s.logger.Error("Unable to load OpenAPI spec", zap.Any("url", url), zap.Error(err))
			return nil
		}
	} else {
		// Marshal the OpenAPI specification to JSON
		data, err := json.Marshal(s.Spec.OpenAPI.Value)
		if err != nil {
			s.logger.Error("Unable to marshal OpenAPI spec", zap.Error(err))
			return nil
		}
		schema, err = loader.LoadFromData(data)
		if err != nil {
			s.logger.Error("Unable to load OpenAPI spec", zap.Error(err))
			return nil
		}
	}

	rpcs := make([]*rpc.RPC, 0)
	for url, pathSpec := range schema.Paths {
		// Process GET requests
		if getSpec := pathSpec.Get; getSpec != nil {
			rpcs = append(rpcs, s.processRequest(url, getSpec, http.MethodGet))
		}

		// Process POST requests
		if postSpec := pathSpec.Post; postSpec != nil {
			rpcs = append(rpcs, s.processRequest(url, postSpec, http.MethodPost))
		}

		// Process PUT requests
		if putSpec := pathSpec.Put; putSpec != nil {
			rpcs = append(rpcs, s.processRequest(url, putSpec, http.MethodPut))
		}

		// Process DELETE requests
		if deleteSpec := pathSpec.Delete; deleteSpec != nil {
			rpcs = append(rpcs, s.processRequest(url, deleteSpec, http.MethodDelete))
		}
	}

	return rpcs
}

func (s *Source) processRequest(url string, operation *openapi3.Operation, method string) *rpc.RPC {
	var respBody *openapi3.Schema
	var reqBody *openapi3.Schema
	var operationType string
	var plugins []v1alpha1.HTTPPlugin

	// Check if the response has a 200 status code
	if res, ok := operation.Responses[strconv.FormatInt(int64(200), 10)]; ok {
		// Check if the response has JSON content
		if content := res.Value.Content.Get("application/json"); content != nil {
			respBody = content.Schema.Value
		}
	}

	// Check if the response has a 204 status code
	if res, ok := operation.Responses[strconv.FormatInt(int64(204), 10)]; ok {
		// Check if the response has JSON content
		if content := res.Value.Content.Get("application/json"); content != nil {
			respBody = content.Schema.Value
		}
	}

	// Get the request body schema
	if operation.RequestBody != nil {
		if reqContent := operation.RequestBody.Value.Content.Get("application/json"); reqContent != nil {
			reqBody = reqContent.Schema.Value
		}
	}

	// Check if operation type is present in extensions
	if ext, ok := operation.Extensions["x-request-op-type"]; ok {
		operationType = ext.(string)
	}

	// Check if plugins is present in extensions
	if ext, ok := operation.Extensions["x-sc-plugins"]; ok {
		// Export value of ext to plugins variable
		if err := mapstructure.Decode(ext, &plugins); err != nil {
			s.logger.Error("Unable to decode x-sc-plugins", zap.Error(err))
		}
	}

	return s.createRPC(url, operation.OperationID, operationType, method, respBody, reqBody, operation.Parameters, plugins)
}

// Interface guards
var (
	_ caddy.Provisioner = (*Source)(nil)
	_ source.Source     = (*Source)(nil)
	_ rpc.Source        = (*Source)(nil)
)
